  SQL数据库面试题 


1、SQL SREVER中，向一个表中插入了新数据，如何快捷的得到自增量字段的当前值

这种情况其实我们经常用到，比如我们新建了一个用户，建立完用户后我们希望马上得到这个新用户的ID，因为我们一般都是把这种用户ID的字段设置成自增长类型的，乍看起来好像没有要得到那个新ID很麻烦，其实sql server内置了一些全局的变量，使我们很容易就得到那个新的自增字段的ID，就是使用@@IDENTITY。

      在一条 INSERT、SELECT INTO 或大容量复制语句完成后，@@IDENTITY 中包含语句生成的最后一个标识值。如果语句未影响任何包含标识列的表，则 @@IDENTITY 返回 NULL。如果插入了多个行，生成了多个标识值，则 @@IDENTITY 将返回最后生成的标识值。如果语句触发了一个或多个触发器，该触发器又执行了生成标识值的插入操作，那么，在语句执行后立即调用 @@IDENTITY 将返回触发器生成的最后一个标识值。

在具体应用中可以这样来写SQL语句：

string strSql = "INSERT INTO [User]([Name],[LoginName],[Pwd],[RegTime],[IsSuper],[Remark])" +
                "VALUES(@Name,@LoginName,@Pwd,@RegTime,@IsSuper,@Remark);select @@IDENTITY ;";

执行的时候直接用command.ExecuteScalar();就可以了，能直接返回该条记录的UserID；

解答二：

经过实验，得如下结论：

select DISTINCT @@IDENTITY as iden from FaWen

解释：上述语句对 SQL SERVER 的一个会话，也就是一条连接，返回该连接最后一条插入记录得到的自增字段的值。

假设有3个程序，分别连接SQL SERVER，有三个连接。3个程序都向同一个表依顺序插入数据，得到的值分别是1、2、3，那么，只要3个程序对SQL的连接还保持着，第一个程序使用上述语句，将得到1，而不是3，第二个程序将得到2，也不是3。第三个程序得到3。

因此，用上述语句可以得到自己刚才插入记录的自增字段的值，不怕其它程序的并发插入操作。

上述语句中，使用 DISTINCT  的原因是，虽然返回的值是当前连接插入操作得到的最大值，但返回的相同值的记录有多条。条数等于当前多个连接一共插入的记录数。

实验方法：启动三个 Query analyzer 查询分析器，分别执行插入操作后再做上述取自增字段值的操作 

 
 
我利用   
  rs.addnew   
  增加一条记录时，如何同时获取自增1字段ID的当前值，而无须再进行一次查询来获取！因为我立即要用到该ID值，如果在增加记录完毕后再利用select   id   进行一次查询无疑会使系统受限，有办法吗？
 
如果你能保证id=行数的话可以用   
  rs.moveend   '当指针在最后一条记录时count是全部行数   
  rs.count
2、什么叫做SQL注入，如何防止？请举例说明

SQL注入就是在正常的SQL执行语句中恶意插入攻击者想要运行的sql语句，比如，我们有一个方法是这么写的:

public static bool Login(string loginName,string pwd)
        {
            string strSql = string.Format("select *  from [User] where LoginName = '{0}' and Pwd = '{1}' ",loginName,pwd);

        ...

          }

如果我传给loginname的值是' or 1=1--，那么这个sql语句成了select *  from [User] where LoginName = '' or 1=1--'，这样不管我密码输入什么，肯定都是符合条件的。当然这只是最简单的情况，如果我把loginname的值改成' or 1=1;delete from [user]--,那么后果不堪设想，如果我通过sql来执行net use相关的命令，就可能在服务器上给自己加一个帐号，这样就逐步可以控制整个数据库所在的服务器。。。

这就是sql注入的通常方法和可能的损害。

要放置其实也很简单，可以通过至少两个方法来进行：

1.最根本的，不实用组合sql的方法，而是通过使用命令参数方式来执行命令，比如我们把sql改成这种方式：

string strSql = "select * from [user] where LoginName =@LoginName and Pwd =@Pwd ";

，然后通过sqlcommand来执行它，就可以从根本上解决这个问题。

2.控制参数的长度。因为要想进行sql注入的话，需要一定长度的字符串才能执行，如果我们规定LoginName 的长度最长不超过8个，一般不会造成损害，当然这个只是在特殊的情况下才使用，比如有些情况可能不能使用命令参数方式。

点评：

sql注入是我们编程时必须考虑的问题，特别是BS的程序，更是要严格检查是否有sql注入的漏洞。最关键的一点是，你要明白怎么解决这个问题，一般面试人员会希望你提高使用参数方式来防止注入。

3、游标的作用?如何知道游标已经到了最后?

关系数据库中的操作会对整个行集起作用。由 SELECT 语句返回的行集包括满足该语句的 WHERE 子句中条件的所有行。这种由语句返回的完整行集称为结果集。应用程序，特别是交互式联机应用程序，并不总能将整个结果集作为一个单元来有效地处理。这些应用程序需要一种机制以便每次处理一行或一部分行。游标就是提供这种机制的对结果集的一种扩展。

游标的特点是：

允许定位在结果集的特定行。 
从结果集的当前位置检索一行或一部分行。 
支持对结果集中当前位置的行进行数据修改。 
为由其他用户对显示在结果集中的数据库数据所做的更改提供不同级别的可见性支持。 
提供脚本、存储过程和触发器中用于访问结果集中的数据的 Transact-SQL 语句 
在从游标中提取信息后，可以通过判断@@FETCH_STATUS 的值来判断是否到了最后。当@@FETCH_STATUS为0的时候，说明提取是成功的，否则就可以认为到了最后。

点评：

游标是进行数据库操作的一个重要概念，但是在现代的软件开发中应用的不是很多，只有在一些特殊的存储过程中才会应用。但是，毕竟这是一个很重要，也是我们必须掌握的概念，最好能理解它的原理和用法。

4、SQL Server的两种索引是何形式？索引的作用？索引的优缺点？

sql server的索引分为聚集索引和非聚集索引，下面分别说明：
聚集索引
聚集索引根据数据行的键值在表或视图中排序和存储这些数据行。索引定义中包含聚集索引列。每个表只能有一个聚集索引，因为数据行本身只能按一个顺序排序。 
只有当表包含聚集索引时，表中的数据行才按排序顺序存储。如果表具有聚集索引，则该表称为聚集表。如果表没有聚集索引，则其数据行存储在一个称为堆的无序结构中。 

非聚集索引
非聚集索引具有独立于数据行的结构。非聚集索引包含非聚集索引键值，并且每个键值项都有指向包含该键值的数据行的指针。 
从非聚集索引中的索引行指向数据行的指针称为行定位器。行定位器的结构取决于数据页是存储在堆中还是聚集表中。对于堆，行定位器是指向行的指针。对于聚集表，行定位器是聚集索引键。 


索引的作用主要是为了在查询时提高查询的效率，并且尽量减小更新时的开销。

优点：

设计良好的索引查询效率可以得到极大的提高，某些情况下甚至可以提高几百上千倍。

缺点：

需要占用额外的空间和资源。在更新时耗费的时间更大，因为对数据的更新很有可能会导致索引的更新，这样就会导致增加系统开销。

点评：

在所有的进行系统优化的选择中，索引都是第一位的，一个设计良好的数据库肯定需要高超的索引设计技巧，在这方面效率提高不是一倍两倍的问题，而是可能会有质的飞跃，对索引优化的重要性，在一个大型项目里，怎么说都不为过。但是，索引优化又是比较困难的，哪些列需要加入索引，列的顺序怎样，哪个索引需要设置为聚集索引等等，都是我们必须要考虑的问题。

5、事务是什么？

事务是单个的工作单元。如果某一事务成功，则在该事务中进行的所有数据修改均会提交，成为数据库中的永久组成部分。

如果事务遇到错误且必须取消或回滚，则所有数据修改均被清除。

也就是说，事务是由一系列的“原子”操作组成的，这些原子操作必须全部完成，否则所有的动作都会被取消并恢复到初始状态。

开始事务使用BEGIN TRANSACTION 语句显，以 COMMIT 或 ROLLBACK 语句结束。

以上是针对数据库来说的。

但是，事务不仅仅限于数据库，数据库以外的动作也可以被组合进事务中，一般称为“企业级事务”。举一个例子：我们有这两个操作必须都完成，即在向数据库插入一条记录后必须在硬盘的某个文件夹内创建一个文件，这个就是一个企业级事务，它超出了简单的数据库事务的范畴。我们可以通过编程来实现企业级事务。

点评：

事务是数据库开发中一个非常重要的概念，它对与保证数据库的完整性和一致性非常重要。对于事务的的C＃代码实现更是务必要熟练掌握。

6、存储过程和函数的区别

?存储过程，功能强大，可以执行包括修改表等一系列数据库操作，也可以创建为 SQL Server 启动时自动运行的存储过程。 
?自定义函数，用户定义函数不能用于执行一组修改全局数据库状态的操作。
 

?存储过程，可以使用非确定函数。 
?自定义函数，不允许在用户定义函数主体中内置非确定函数。
 

?存储过程，可返回记录集。 
?自定义函数，可以返回表变量,也可以有任意个输出参数，
 

?存储过程，其返回值不能被直接引用,必须单独调用
?自定义函数，其返回值可以被直接引用,也就是可以直接 select * from 函数
