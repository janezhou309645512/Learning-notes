
Android面试题


1.下列哪些语句关于内存回收的说明是正确的? (b )
A、 程序员必须创建一个线程来释放内存
  B、 内存回收程序负责释放无用内存
  C、 内存回收程序允许程序员直接释放内存
  D、 内存回收程序可以在指定的时间释放内存对象

2.下面异常是属于Runtime Exception 的是（abcd）(多选)
      A、ArithmeticException
      B、IllegalArgumentException
      C、NullPointerException
      D、BufferUnderflowException

3.Math.round(11.5)等于多少(). Math.round(-11.5)等于多少(c). c
    A、11 ,-11   B、11 ,-12   C、12 ,-11   D、12 ,-12

4. 下列程序段的输出结果是：（b ）
     void complicatedexpression_r(){
     int x=20, y=30;
     boolean b;
     b=x>50&&y>60||x>50&&y<-60||x<-50&&y>60||x<-50&&y<-60;
     System.out.println(b);
     }
     A、true  B、false  C、1  D、011.activity

5.对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行(d)
   A、onPause()  B、onCreate()   C、onResume()   D、onStart()

6.Intent传递数据时，下列的数据类型哪些可以被传递（abcd）(多选)
       A、Serializable  B、charsequence  C、Parcelable  D、Bundle

7.android 中下列属于Intent的作用的是(c)
  A、实现应用程序间的数据共享
  B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失
  C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带
  D、处理一个应用程序整体性的工作

8.下列属于SAX解析xml文件的优点的是(b)
      A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能
      B、不用事先调入整个文档，占用资源少
      C、整个文档调入内存，浪费时间和空间
      D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会
  消失

9.下面的对自定style的方式正确的是（a）
    A、 <resources>
       <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
                     </style>
</resources>
     B、 <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
   </style>
     C、 <resources>
                            <itemname="android:layout_width">fill_parent</item>
  </resources>
     D、 <resources>
                            <stylename="android:layout_width">fill_parent</style>
  </resources>

10.在android中使用Menu时可能需要重写的方法有（ac）。(多选)
      A、onCreateOptionsMenu()
  B、onCreateMenu()
  C、onOptionsItemSelected()
  D、onItemSelected()

11.在SQL ServerManagement Studio 中运行下列T-SQL语句，其输出值（c）。
SELECT @@IDENTITY  
     A、      可能为0.1
     B、       可能为3
     C、     不可能为-100
     D、      肯定为0

12.在SQL Server 2005中运行如下T-SQL语句，假定SALES表中有多行数据，执行查询之后的结果是（d）。
BEGIN TRANSACTION A
       Update SALES Set qty=30 WHERE qty<30
        BEGIN TRANSACTION B
              UpdateSALES Set qty=40 WHERE qty<40
              UpdateSALES Set qty=50 WHERE qty<50
              UpdateSALES Set qty=60 WHERE qty<60
        COMMIT　TRANSACTION B
        COMMIT TRANSACTION A
A、SALES表中qty列最小值大于等于30
B、SALES表中qty列最小值大于等于40
C、SALES表中qty列的数据全部为50
D、SALES表中qty列最小值大于等于60

13.在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库版本进行管理的方法可以是(ab)
    A、getWriteableDatabase()
B、getReadableDatabase()
C、getDatabase()
D、getAbleDatabase()

14.android 关于service生命周期的onCreate()和onStart()说法正确的是(ad)(多选题)
    A、当第一次启动的时候先后调用onCreate()和onStart()方法
    B、当第一次启动的时候只会调用onCreate()方法
    C、如果service已经启动，将先后调用onCreate()和onStart()方法
D、如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法

15.下面是属于GLSurFaceView特性的是(abc)(多选)
A、管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图
    view上。
B、管理一个EGL display，它能让opengl把内容渲染到上述的surface上。
C、让渲染器在独立的线程里运作，和UI线程分离。
D、可以直接从内存或者DMA等硬件接口取得图像数据

16.下面在AndroidManifest.xml文件中注册BroadcastReceiver方式正确的(a)
       A、<receiver android:name="NewBroad">
                     <intent-filter>
                            <action  
                   android:name="android.provider.action.NewBroad"/>
                <action>
                     </intent-filter>
              </receiver>
     B、<receiver android:name="NewBroad">
                     <intent-filter>
                   android:name="android.provider.action.NewBroad"/>
                     </intent-filter>
              </receiver>
     C、<receiver android:name="NewBroad">
                     <action  
                  android:name="android.provider.action.NewBroad"/>
             <action>
              </receiver>
     D、<intent-filter>
         <receiver android:name="NewBroad">
                           <action>
                   android:name="android.provider.action.NewBroad"/>
                  <action>
                     </receiver>
</intent-filter>

17.关于ContentValues类说法正确的是(a)
     A、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的
        名是String类型，而值都是基本类型
     B、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的
        名是任意类型，而值都是基本类型
     C、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的
        名，可以为空，而值都是String类型      
     D、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中
        的名是String类型，而值也是String类型

18.我们都知道Hanlder是线程与Activity通信的桥梁,如果线程处理不当，你的机器就会变得越慢，那么线程销毁的方法是(a)
      A、onDestroy()
      B、onClear()
      C、onFinish()
      D、onStop()

19.下面退出Activity错误的方法是（c）
       A、finish()
         B、抛异常强制退出
       C、System.exit()
       D、onStop()

20.下面属于android的动画分类的有(ab)(多项)
       A、Tween  B、Frame C、Draw D、Animation



21.下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是(d)
        A、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立 的Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念.
        B、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程,所以说不是一个概念.
        C、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程,所以说不是一个概念.
        D、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念.
22.Android项目工程下面的assets目录的作用是什么b
A、放置应用到的图片资源。
B、主要放置多媒体等数据文件
C、放置字符串，颜色，数组等常量数据
D、放置一些与UI相应的布局文件，都是xml文件
23.关于res/raw目录说法正确的是(a)
A、这里的文件是原封不动的存储到设备上不会转换为二进制的格式
B、 这里的文件是原封不动的存储到设备上会转换为二进制的格式
C、这里的文件最终以二进制的格式存储到指定的包中
D、 这里的文件最终不会以二进制的格式存储到指定的包中
24.下列对android NDK的理解正确的是(abcd )
A、 NDK是一系列工具的集合
B、 NDK 提供了一份稳定、功能有限的API 头文件声明。
C、 使 “Java+C”的开发方式终于转正，成为官方支持的开发方式
D、 NDK 将是 Android 平台支持 C 开发的开端
二．填空题
25.android中常用的四个布局是：framlayout，linenarlayout，relativelayout和tablelayout。

26.android 的四大组件是：activity，service，broadcast和contentprovider。


27.java.io包中的objectinputstream和objectoutputstream类主要用于对对象(Object)的读写。


28.android 中service的实现方法是：startservice和bindservice。


29. activity一般会重载7个方法用来维护其生命周期，除了onCreate(),onStart(),onDestory()   外还有：onRestart(),onResume(),onPause(),onStop()。


30.android的数据存储的方式sharedpreference,文件,SQlite,contentprovider,网络。


31.当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activity来执行的回调函数是：startActivityResult()。

32.请使用命令行的方式创建一个名字为myAvd,sdk版本为2.2,sd卡是在d盘的根目录下,名字为scard.img，并指定屏幕大小HVGA.

33.程序运行的结果是：good and gbc
    public classExample{
　　String str=newString("good");
　　char[]ch={'a','b','c'};
　　public static voidmain(String args[]){
　　　　Example ex=new Example();
　　　　ex.change(ex.str,ex.ch);
　　　　System.out.print(ex.str+"and ");
　　　　Sytem.out.print(ex.ch);
　　}
　　public void change(Stringstr,char ch[]){
　　　　str="test ok";
　　　　ch[0]='g';
　　}
}

34.在android中，请简述jni的调用过程。
1)安装和下载Cygwin，下载 AndroidNDK
  2)在ndk项目中JNI接口的设计
  3)使用C/C++实现本地方法
  4)JNI生成动态链接库.so文件
  5)将动态链接库复制到java工程，在java工程中调用，运行java工程即可

35.简述Android应用程序结构是哪些?
Android应用程序结构是：
  Linux Kernel(Linux内核)、Libraries(系统运行库或者是c/c++核心库)、Application  
  Framework(开发框架包)、Applications  (核心应用程序)

36.请继承SQLiteOpenHelper实现：
   1）.创建一个版本为1的“diaryOpenHelper.db”的数据库，
   2）.同时创建一个 “diary” 表（包含一个_id主键并自增长，topic字符型100
       长度， content字符型1000长度）
    3）.在数据库版本变化时请删除diary表，并重新创建出diary表。
publicclass DBHelper  extends SQLiteOpenHelper{
       public final static String DATABASENAME ="diaryOpenHelper.db";
       public final static int DATABASEVERSION =1;
       //创建数据库
       public DBHelper(Context context,Stringname,CursorFactory factory,int version)
       {
              super(context,name, factory, version);
       }
       //创建表等机构性文件
       public void onCreate(SQLiteDatabase db)
       {
              Stringsql ="create table diary"+
                                   "("+
                                   "_id integer primary keyautoincrement,"+
                                   "topic varchar(100),"+
                                   "content varchar(1000)"+
                                   ")";
              db.execSQL(sql);
       }
       //若数据库版本有更新，则调用此方法
       public void onUpgrade(SQLiteDatabasedb,int oldVersion,int newVersion)
       {
              
              Stringsql = "drop table if exists diary";
              db.execSQL(sql);
              this.onCreate(db);
       }
}

37.页面上现有ProgressBar控件progressBar，请用书写线程以10秒的的时间完成其进度显示工作。
答案
publicclass ProgressBarStu extends Activity {
       private ProgressBar progressBar = null;
       protected void onCreate(BundlesavedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.progressbar);
              //从这到下是关键
              progressBar= (ProgressBar)findViewById(R.id.progressBar);
              
              Threadthread = new Thread(new Runnable() {
                     
                     @Override
                     public void run() {
                            intprogressBarMax = progressBar.getMax();
                            try{
                                   while(progressBarMax!=progressBar.getProgress())
                                   {
                                          
                                          intstepProgress = progressBarMax/10;
                                          intcurrentprogress = progressBar.getProgress();
                                          progressBar.setProgress(currentprogress+stepProgress);
                                          Thread.sleep(1000);
                                   }
                                   
                            }catch (InterruptedException e) {
                                   // TODO Auto-generated catch block
                                   e.printStackTrace();
                            }
                           
                     }
              });
              
              thread.start();
              //关键结束
       }
      
}

38.请描述下Activity的生命周期。
      必调用的三个方法：onCreate() --> onStart() -->onResume()，用AAA表示
（1）父Activity启动子Activity，子Actvity退出，父Activity调用顺序如下
AAA --> onFreeze() --> onPause() --> onStop() --> onRestart()--> onStart(),onResume() …
（2）用户点击Home，Actvity调用顺序如下
AAA --> onFreeze() --> onPause() --> onStop() -- Maybe -->onDestroy() C Maybe
（3）调用finish()， Activity调用顺序如下
AAA --> onPause() --> onStop() --> onDestroy()
（4）在Activity上显示dialog， Activity调用顺序如下
AAA
（5）在父Activity上显示透明的或非全屏的activity，Activity调用顺序如下
AAA --> onFreeze() --> onPause()
（6）设备进入睡眠状态，Activity调用顺序如下
AAA --> onFreeze() --> onPause()

39. 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？
      onSaveInstanceState()
      当你的程序中某一个Activity A在运行时，主动或被动地运行另一个新的Activity B，这个时候A会执行onSaveInstanceState()。B完成以后又会来找A，这个时候就有两种情况：一是A被回收，二是A没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上了参数savedInstanceState；而没被收回的就直接执行onResume()，跳过onCreate()了。

40. 如何将一个Activity设置成窗口的样式。
      在AndroidManifest.xml 中定义Activity的地方一句话android:theme="@android:style/Theme.Dialog"或android:theme="@android:style/Theme.Translucent"就变成半透明的



本帖最后由 咫尺的梦想 于 2015-4-16 12:47 编辑


41.如何退出Activity？如何安全退出已调用多个Activity的Application？
对于单一Activity的应用来说，退出很简单，直接finish()即可。
当然，也可以用killProcess()和System.exit()这样的方法。

但是，对于多Activity的应用来说，在打开多个Activity后，如果想在最后打开的Activity直接退出，上边的方法都是没有用的，因为上边的方法都是结束一个Activity而已。
当然，网上也有人说可以。
就好像有人问，在应用里如何捕获Home键，有人就会说用keyCode比较KEYCODE_HOME即可，而事实上如果不修改framework，根本不可能做到这一点一样。
所以，最好还是自己亲自试一下。

那么，有没有办法直接退出整个应用呢？
在2.1之前，可以使用ActivityManager的restartPackage方法。
它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。
注意不要被它的名字迷惑。

可是，在2.2，这个方法失效了。
在2.2添加了一个新的方法，killBackgroundProcesses()，需要权限android.permission.KILL_BACKGROUND_PROCESSES。
可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。

另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。
它需要权限android.permission.FORCE_STOP_PACKAGES。
并且需要添加android:sharedUserId="android.uid.system"属性
同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。
因为需要在Android.mk中添加LOCAL_CERTIFICATE:= platform。
而Android.mk是用于在Android源码下编译程序用的。

从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。

现提供几个方法，供参考：

1、抛异常强制退出：
该方法通过抛异常，使程序ForceClose。
验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。

2、记录打开的Activity：
每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。

3、发送特定广播：
在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。

4、递归退出
在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。

除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。
但是这样做同样不完美。
你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。
但至少，我们的目的达到了，而且没有影响用户使用。

为了编程方便，最好定义一个Activity基类，处理这些共通问题。


42.请介绍下Android中常用的五种布局。
FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）


43.请介绍下Android的数据存储方式。
一.SharedPreferences方式
二.文件存储方式
三.SQLite数据库方式
四.内容提供器（Content provider）方式
五. 网络存储方式


44.请介绍下ContentProvider是如何实现数据共享的。
创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。


45.如何启用Service，如何停用Service。
Android中的service类似于windows中的service，service一般没有用户操作界面，它运行于系统中不容易被用户发觉，
可以使用它开发如监控之类的程序。
一。步骤
第一步：继承Service类
public class SMSService extends Service { }
第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:
<service android:name=".DemoService" />
二。Context.startService()和Context.bindService
服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可
以启动Service，但是它们的使用场合有所不同。
1.使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。
使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
2.采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，
接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并
不会导致多次创建服务，但会导致多次调用onStart()方法。
采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用
onDestroy()方法。 
3.采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，
接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，
。接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会
导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务
解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。
三。Service的生命周期
1.Service常用生命周期回调方法如下：

onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，
服务也只被创建一次。 onDestroy()该方法在服务被终止时调用。 
2. Context.startService()启动Service有关的生命周期方法
onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。
多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。

3. Context.bindService()启动Service有关的生命周期方法
onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，
当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。
onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。
备注：
1. 采用startService()启动服务
     Intent intent = newIntent(DemoActivity.this, DemoService.class);
    startService(intent);
2.Context.bindService()启动
    Intent intent =new Intent(DemoActivity.this, DemoService.class);
   bindService(intent, conn, Context.BIND_AUTO_CREATE);
   //unbindService(conn);//解除绑定


46.注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。
  Android广播机制（两种注册方法）
在android下，要想接受广播信息，那么这个广播接收器就得我们自己来实现了，我们可以继承BroadcastReceiver，就可以有一个广播接受器了。有个接受器还不够，我们还得重写BroadcastReceiver里面的onReceiver方法，当来广播的时候我们要干什么，这就要我们自己来实现，不过我们可以搞一个信息防火墙。具体的代码：
public class SmsBroadCastReceiverextends BroadcastReceiver   
{  
   @Override  
   public void onReceive(Context context, Intent intent)   
   {   
       Bundle bundle = intent.getExtras();  
       Object[] object = (Object[])bundle.get("pdus");   
       SmsMessage sms[]=new SmsMessage[object.length];   
       for(int i=0;i<object.length;i++)  
       {   
            sms[0] =SmsMessage.createFromPdu((byte[])object);  
            Toast.makeText(context, "来自"+sms.getDisplayOriginatingAddress()+"的消息是："+sms.getDisplayMessageBody(),Toast.LENGTH_SHORT).show();   
       }   
       //终止广播，在这里我们可以稍微处理，根据用户输入的号码可以实现短信防火墙。   
       abortBroadcast();   
   }   
      
}
当实现了广播接收器，还要设置广播接收器接收广播信息的类型，这里是信息：android.provider.Telephony.SMS_RECEIVED
我们就可以把广播接收器注册到系统里面，可以让系统知道我们有个广播接收器。这里有两种，一种是代码动态注册：
//生成广播处理  
smsBroadCastReceiver = newSmsBroadCastReceiver();   
//实例化过滤器并设置要过滤的广播  
IntentFilter intentFilter = newIntentFilter("android.provider.Telephony.SMS_RECEIVED");
//注册广播   
BroadCastReceiverActivity.this.registerReceiver(smsBroadCastReceiver,intentFilter);  
一种是在AndroidManifest.xml中配置广播
<?xml version="1.0"encoding="utf-8"?>  
<manifestxmlns:android="http://schemas.android.com/apk/res/android"  
     package="spl.broadCastReceiver"  
     android:versionCode="1"
     android:versionName="1.0">
   <application android:icon="@drawable/icon"android:label="@string/app_name">
       <activity android:name=".BroadCastReceiverActivity"  
                  android:label="@string/app_name">  
            <intent-filter>  
                <actionandroid:name="android.intent.action.MAIN" />  
                <categoryandroid:name="android.intent.category.LAUNCHER" />  
            </intent-filter>  
       </activity>  
           
       <!--广播注册-->  
       <receiver android:name=".SmsBroadCastReceiver">  
            <intent-filterandroid:priority="20">  
                <actionandroid:name="android.provider.Telephony.SMS_RECEIVED"/>  
           </intent-filter>  
       </receiver>  
           
   </application>  
      
   <uses-sdk android:minSdkVersion="7" />  
      
   <!-- 权限申请 -->  
   <uses-permissionandroid:name="android.permission.RECEIVE_SMS"></uses-permission>  
      
</manifest>   
两种注册类型的区别是：
    1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。
    2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。


47.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。
Handler简介：
一个Handler允许你发送和处理Message和Runable对象，这些对象和一个线程的MessageQueue相关联。每一个线程实例和一个单独的线程以及该线程的MessageQueue相关联。当你创建一个新的Handler时，它就和创建它的线程绑定在一起了。这里，线程我们也可以理解为线程的MessageQueue。从这一点上来看，Handler把Message和Runable对象传递给MessageQueue，而且在这些对象离开MessageQueue时，Handler负责执行他们。

Handler有两个主要的用途：（1）确定在将来的某个时间点执行一个或者一些Message和Runnable对象。（2）在其他线程（不是Handler绑定线程）中排入一些要执行的动作。

Scheduling Message，即（1），可以通过以下方法完成：
post(Runnable):Runnable在handler绑定的线程上执行，也就是说不创建新线程。
postAtTime(Runnable,long):
postDelayed(Runnable,long):
sendEmptyMessage(int):
sendMessage(Message):
sendMessageAtTime(Message,long):
sendMessageDelayed(Message,long):
post这个动作让你把Runnable对象排入MessageQueue,MessageQueue受到这些消息的时候执行他们，当然以一定的排序。sendMessage这个动作允许你把Message对象排成队列，这些Message对象包含一些信息，Handler的hanlerMessage(Message)会处理这些Message.当然，handlerMessage(Message)必须由Handler的子类来重写。这是编程人员需要作的事。

当posting或者sending到一个Hanler时，你可以有三种行为：当MessageQueue准备好就处理，定义一个延迟时间，定义一个精确的时间去处理。后两者允许你实现timeout,tick,和基于时间的行为。

当你的应用创建一个新的进程时，主线程（也就是UI线程）自带一个MessageQueue，这个MessageQueue管理顶层的应用对象（像activities,broadcastreceivers等）和主线程创建的窗体。你可以创建自己的线程，并通过一个Handler和主线程进行通信。这和之前一样，通过post和sendmessage来完成，差别在于在哪一个线程中执行这么方法。在恰当的时候，给定的Runnable和Message将在Handler的MessageQueue中被Scheduled。


Message简介：
Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。
尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用Message.obtain(),或者Handler.obtainMessage()方法，这些方法会从回收对象池中获取一个。


MessageQueue简介：
这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。
你可以通过Looper.myQueue()从当前线程中获取MessageQueue。


Looper简介：
Looper类被用来执行一个线程中的message循环。默认情况，没有一个消息循环关联到线程。在线程中调用prepare()创建一个Looper，然后用loop()来处理messages，直到循环终止。

大多数和message loop的交互是通过Handler。

下面是一个典型的带有Looper的线程实现。
  class LooperThread extends Thread {
      public Handler mHandler;
      
      public void run() {
          Looper.prepare();
          
          mHandler = new Handler() {
              public voidhandleMessage(Message msg) {
                  // process incomingmessages here
              }
          };
          
          Looper.loop();
      }
  }


48.AIDL的全称是什么？如何工作？能处理哪些类型的数据？
AIDL的英文全称是Android InterfaceDefine Language
当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的
A工程：
首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。
说明一：aidl文件的位置不固定，可以任意
然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。
其次需要在AndroidManifest.xml文件中配置MyService类，代码如下：
<!-- 注册服务 -->  
<service android:name=".MyService">
  <intent-filter>
   <!--  指定调用AIDL服务的ID  -->
       <actionandroid:name="net.blogjava.mobile.aidlservice.RemoteService" />
   </intent-filter>
</service>
为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。
说明：AIDL并不需要权限
B工程：
      首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务
      绑定AIDL服务就是将RemoteService的ID作为intent的action参数。
      说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件
          bindService(newInten("net.blogjava.mobile.aidlservice.RemoteService"),serviceConnection, Context.BIND_AUTO_CREATE);
      ServiceConnection的onServiceConnected(ComponentNamename, IBinder service)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。


49. 请解释下Android程序运行时权限与文件系统权限的区别。
运行时权限Dalvik( android授权)
文件系统 linux 内核授权


50.系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。
通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性

**************************************************

1、Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念
　　DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念。
2、sim卡的EF文件有何作用
　　sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的
3、嵌入式操作系统内存管理有哪几种，各有何特性
　　页式，段式，段页，用到了MMU,虚拟空间等技术
4、什么是嵌入式实时操作系统,Android 操作系统属于实时操作系统吗?
　　嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。
5、一条最长的短信息约占多少byte?
　　中文70(包括标点)，英文160，160个字节。
6、android中的动画有哪几类，它们的特点和区别是什么?
　　两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。
7、handler机制的原理
　　andriod提供了 Handler 和Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。
　　1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。
　　2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从MessageQueue取出)所送来的消息。
　　3) Message Queue(消息队列):用来存放线程放入的消息。
　　4)线程：UI thread 通常就是mainthread，而Android启动程序时会替它建立一个MessageQueue。
8、说说mvc模式的原理，它在android中的运用
　MVC(Model_view_controller)”模型_视图_控制器”。MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Controllerller改变了View，View会 从潜在的Model中获取数据来刷新自己
（View重绘和内存泄露面试经常问的问题 ）
mvc是model,view,controller的缩写，mvc包含三个部分：

　　l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。
　　2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。
　　3控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给model对象处理。

　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：
    1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定 可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。
　2)控制层（controller）：android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。
　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。
9、View的刷新:
在需要刷新的地方,使用handle.sendmessage发送信息,然后在handle的getmessage里面执行invaliate或者postinvaliate。
可以调用invalidate()和postInvalidate()这两个方法刷新

10、GC内存泄露 出现情况:
1）.数据库的cursor没有关闭
2）.构造adapter时,没有使用缓存contentview 衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程/
3）.Bitmap对象不使用时采用recycle()释放内存
4）.activity中的对象的生命周期大于activity 调试方法: DDMS==> HEAPSZIE==>dataobject==>[Total Size]

2.横竖屏切换时候activity的生命周期
1.不设置Activity的android:configChanges时,切屏会重新调用各个生命周期,切横屏时会执行一次,切竖屏时会执行两次. 
2.设置Activity的android:configChanges="orientation"时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次. 
3.设置Activity的android:configChanges="orientation|keyboardHidden"时,切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法.

6.什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?
　　嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。



【附件】   Android面试题总结强劲版(二).rar (17.38 KB, 下载次数: 6)
【001】Android常用控件的信息
单选框(RadioButton与RadioGroup)：
RadioGroup用于对单选框进行分组，相同组内的单选框只有一个单选框被选中。
事件：setOnCheckedChangeListener()，处理单选框被选择事件。把RadioGroup.OnCheckedChangeListener实例作为参数传入。
多选框(CheckBox):
每个多选框都是独立的，可以通过迭代所有的多选框，然后根据其状态是否被选中在获取其值。
事件：setOnCheckChangeListener()处理多选框被选择事件。把CompoundButton.OnCheckedChangeListener实例作为参数传入
下拉列表框(Spring)：
Spinner.getItemAtPosition(Spinner.getSelectedItemPosition());获取下拉列表框的值。
事件：setOnItemSelectedListener(),处理下拉列表框被选择事件把AdapterView.OnItemSelectedListener实例作为参数传入；
拖动条(SeekBar)：
SeekBar.getProgress()获取拖动条当前值
事件:setOnSeekBarChangeListener()，处理拖动条值变化事件，把SeekBar.OnSeekBarChangeListener实例作为参数传入。
菜单(Menu):
重写Activity的onCreatOptionMenu(Menu menu)方法，该方法用于创建选项菜单，咋用户按下手机的"Menu"按钮时就会显示创建好的菜单，在onCreatOptionMenu(Menu Menu)方法内部可以调用Menu.add()方法实现菜单的添加。
重写Activity的onMenuItemSelected()方法，该方法用于处理菜单被选择事件。
进度对话框(ProgressDialog)：
创建并显示一个进度对话框：ProgressDialog.show(ProgressDialogActivity.this,"请稍等"，"数据正在加载中...."，true)；
设置对话框的风格：setProgressStyle()
ProgressDialog.STYLE_SPINNER  旋转进度条风格(为默认风格)
ProgressDialog.STYLE_HORIZONTAL 横向进度条风格

【002】请介绍下Android中常用的五种布局
Android布局是应用界面开发的重要一环，在Android中，共有五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），
AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。
  1.FrameLayout   
    这个布局可以看成是墙脚堆东西，有一个四方的矩形的左上角墙脚，我们放了第一个东西，要再放一个，那就在放在原来放的位置的上面，这样依次的放，会盖住原来的东西。这个布局比较简单，也只能放一点比较简单的东西。   
2.LinearLayout   
线性布局，这个东西，从外框上可以理解为一个div，他首先是一个一个从上往下罗列在屏幕上。每一个LinearLayout里面又可分为垂直布局 （android:orientation="vertical"）和水平布局（android:orientation="horizontal" ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。   
linearLayout中有一个重要的属性 android:layout_weight="1"，这个weight在垂直布局时，代表行距；水平的时候代表列宽；weight值越大就越大。   
3.AbsoluteLayout   
    绝对布局犹如div指定了absolute属性，用X,Y坐标来指定元素的位置android:layout_x="20px" android:layout_y="12px" 这种布局方式也比较简单，但是在垂直随便切换时，往往会出问题，而且多个元素的时候，计算比较麻烦。   
4.RelativeLayout   
    相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：   
    相对于某一个元素   
    android:layout_below="@id/aaa" 该元素在 id为aaa的下面   
    android:layout_toLeftOf="@id/bbb" 改元素的左边是bbb   
     相对于父元素的地方   
     android:layout_alignParentLeft="true"  在父元素左对齐   
     android:layout_alignParentRight="true" 在父元素右对齐   
     还可以指定边距等，具体详见API   
            
5.TableLayout   
     表格布局类似Html里面的Table。每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素，设定他的对齐方式 android:gravity="" 。   
     每一个布局都有自己适合的方式，另外，这五个布局元素可以相互嵌套应用，做出美观的界面。



本帖最后由 薄荷凉 于 2014-4-5 16:29 编辑


【附件】   Android面试题总结强劲版(三).rar (20.1 KB, 下载次数: 8)

【001】如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？
当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 
这个时候A会执行
Java代码
public void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    outState.putLong("id", 1234567890);}  
B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回
收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数savedInstanceState，没被收回的就还是onResume就好了。
savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会 用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。
Java代码
if(savedInstanceState != null){  
     long id = savedInstanceState.getLong("id");  
}  
就像官方的Notepad教程 里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来，程序就完整 一些。这也是看你的应用需不需要保存什么，比如你的界面就是读取一个列表，那就不需要特殊记住什么，哦， 没准你需要记住滚动条的位置...

【002】如何退出Activity
对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。现提供几个方法，供参考：
1、抛异常强制退出：该方法通过抛异常，使程序Force Close。验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。
2、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。
3、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。
4、递归退出在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。

【003】请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。
Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列
　　 Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息
　　 Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的
　　　　Handler，Handler接受到消息后调用handleMessage进行处理
　　 Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理.

【004】你如何评价Android系统？优缺点。
答：优点：1、学习的开源性
　　 2、软件兼容性比较好
　　 3、软件发展迅速
　　 4、界面布局好
　　 缺点：1、版本过多
　　       2、先有软件少  3、商务性能差




1，++i和i++ 区别
2，makefile文件代码，写代码
3，隐藏与重写的区别
4，linux 基本命令使用   如：如何查询帮助文档（man）,如何查处文件(fiind)，常用命令
5，进程间通信有几种，效率如何
6、 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?
7，tcp/ip 有几层
8、一条最长的短信息约占多少byte?
9，p2p 和SMTP分别在哪层
10、 android中的动画有哪几类，它们的特点和区别是什么?
11，多态概念（父类引用子类参数）
12、handler机制的原理
13，java 写1+N的和
14，数据结构与算法  如 排序，二叉树
15,MVC概念（为什么有DAO层，什么作用）
16，GC回收机制
17、说说mvc模式的原理，它在android中的运用
18，android项目 自述
19，java 的进程与线程维护
20、Activity的生命周期
21，N*N 打印出来的样子是（例如N=4）  1  2   3   4
                                       12  13 14   5
                                       11  16 15   6
                                       10   9  8   7
22，linux 末行，输入，命令三个模式
23、 Android dvm的进程和Linux的进程,应用程序的进程是否为同一个概念
24，android 四层架构分别的作用（android系统框图）
25、sim卡的EF 文件有何作用


本帖最后由 薄荷凉 于 2014-4-5 16:44 编辑


1、什么是ANR 如何避免它?
　　答：ANR：Application Not Responding，五秒
在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：
　　对输入事件(如按键、触摸屏事件)的响应超过5秒
　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕
　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。
　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束-- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。

　　2、什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?
　　答：一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误

　　3、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?

    4、简要解释一下activity、intent 、intent、filter、service、Broadcase、BroadcaseReceiver
　　答：一个activity呈现了一个用户可以操作的可视化用户界面
　　一个service不包含可见的用户界面，而是在后台无限地运行
　　可以连接到一个正在运行的服务中，连接后，可以通过服务中暴露出来的借口与其进行通信
　　一个broadcast receiver是一个接收广播消息并作出回应的component，broadcastreceiver没有界面
　　intent:content provider在接收到ContentResolver的请求时被激活。
　　activity, service和broadcast receiver是被称为intents的异步消息激活的。
一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI
　　Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。
　　它是通过将Intent对象和目标的intent filter相比较来完成这一工作的。一个component的intentfilter告诉android该component能处理的intent。intentfilter也是在manifest文件中声明的。
　　5、IntentService有何优点?
　　答：IntentService 的好处
　　* Acitivity的进程，当处理Intent的时候，会产生一个对应的Service
　　* Android的进程处理器现在会尽可能的不kill掉你
　　* 非常容易使用
　　6、横竖屏切换时候activity的生命周期?
　　1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次
　　2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次
　　3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法



1.java.io包中定义了多个流类型来实现输入和输出功能，可以从不同的角度对其进行分   类,按功能分为：(c),如果为读取的内容进行处理后再输出，需要使用下列哪种流？(g)
     A、输入流和输出流  B、字节流和字符流  C、节点流和处理流  
     D、File stream  E、Pipe stream  F、Random stream  G、Filter stream
    2.下列代码的执行结果是：（b）
        public class Test3{
        public static void main(String args[]){
        System.out.print(100%3);
        System.out.print(",");
        System.out.println(100%3.0);
        }
        }
        A、1,1
        B、1,1.0
          C、1.0,1
        D、1.0,1.0
   3.在继承中，关于构造方法的说明，下列说法错误的是（d）
　　 A、子类无条件的继承父类的无参构造方法，
　　 B、子类可以引用父类中的有参构造方法，使用super关键字，
　　 C、如果子类没有构造方法，则父类无参构造方法作为自已的构造方法，
　　 D、如果子类有无参构造方法，而父类的无参构造方法则被覆盖。
   4.以下程序的运行结果为（  b）
public class IfTest{
public static void main(String args[]){
int x=3;
int y=1;
if(x==y)
System.out.println("Not equal");
else
System.out.println("Equal");
}
}
     A、Not equal     B、Equal    C、无输出    D、编译出错
   5.Java语言中字符串“学Java”所占的内存空间是(a)
        A. 6个字节
      B. 7个字节
      C. 10个字节
      D. 11个字节
6.关于下列程序段的输出结果，说法正确的是：（d ）
     public class MyClass{
static int i;
     public static void main(Stringargv[]){
     System.out.println(i);
     }
     }
     A、有错误，变量i没有初始化。
     B、null
        C、1
     D、0
7.下列哪些语句关于内存回收的说明是正确的? (b )
  A、 程序员必须创建一个线程来释放内存
  B、 内存回收程序负责释放无用内存
  C、 内存回收程序允许程序员直接释放内存
  D、 内存回收程序可以在指定的时间释放内存对象
8.下面异常是属于Runtime Exception 的是（abcd）(多选)
     A、ArithmeticException
     B、IllegalArgumentException
     C、NullPointerException
     D、BufferUnderflowException
9. Math.round(11.5)等于多少(). Math.round(-11.5)等于多少(c). c
     A、11 ,-11   B、11 ,-12   C、12 ,-11   D、12 ,-12
10.下列程序段的输出结果是：（b ）
     void complicatedexpression_r(){
     int x=20, y=30;
     boolean b;
     b=x>50&&y>60||x>50&&y<-60||x<-50&&y>60||x<-50&&y<-60;
     System.out.println(b);
     }
     A、true  B、false  C、1  D、0
11.activity对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行(d)
   A、onPause()  B、onCreate()   C、 onResume()   D、onStart()
12.Intent传递数据时，下列的数据类型哪些可以被传递（abcd）(多选)
      A、Serializable  B、charsequence  C、Parcelable  D、Bundle
13.android 中下列属于Intent的作用的是(c)
  A、实现应用程序间的数据共享
  B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失
  C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带
  D、处理一个应用程序整体性的工作
14.下列属于SAX解析xml文件的优点的是(b)
      A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能
      B、不用事先调入整个文档，占用资源少
      C、整个文档调入内存，浪费时间和空间
      D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会
  消失
15.下面的对自定style的方式正确的是（a）
    A、 <resources>
       <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
                     </style>
</resources>
     B、 <stylename="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
   </style>
     C、 <resources>
                            <itemname="android:layout_width">fill_parent</item>
  </resources>
     D、 <resources>
                            <stylename="android:layout_width">fill_parent</style>
  </resources>

 
       1. 请描述下Activity的生命周期。

　　2. 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态?
调用onSaveInstanceState();

       3. 如何将一个Activity设置成窗口的样式。(Editedby Sodino)
单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的
地方一句话：
Xml代码
1.   android :theme="@android:style/Theme.Dialog"   
2.     
3.   android:theme="@android:style/Theme.Dialog"   
4.   
这就使你的应用程序变成对话框的形式弹出来了，或者
Xml代码
1.   android:theme="@android:style/Theme.Translucent"   
2.     
3.   android:theme="@android:style/Theme.Translucent"   
4.     
就变成半透明的，[友情提示-.-]类似的这种activity的属性可以在android.R.styleable 类的AndroidManifestActivity 方法中看到，AndroidManifest.xml中所有元素的属性的介绍都可以参考这个类android.R.styleable
上面说的是属性名称，具体有什么值是在android.R.style中可以看到，比如这个"@android:style/Theme.Dialog" 就对应于android.R.style.Theme_Dialog ,（'_'换成'.' <--注意：这个是文章内容不是笑脸）就可以用在描述文件中了,找找类定义和描述文件中的对应关系就都明白了。

　　4. 如何退出Activity?如何安全退出已调用多个Activity的Application?

　　5. 请介绍下Android中常用的五种布局。

　　6. 请介绍下Android的数据存储方式。(Edited by Sodino)

       7. 请介绍下ContentProvider是如何实现数据共享的。(Editedby Sodino)
SharedPreferences：用来存储”key-valuepaires“格式的数据，它是一个轻量级的键值存储机制，只可以存储基本数据类型。

文件存储：通过FileInputStream和FileOutputStream对文件进行操作。在Android中，文件是一个应用程序私有的，一个应用无法读写其他应用程序的文件。

3.SQLite数据库存储：Android提供的一个标准数据库，支持SQL语句。 
网络：通过网络来存储和获得数据。

ContentProvider：是所有应用程序之间数据存储和检索的一个桥梁，它的作用就是使得各个应用程序之间实现数据共享。它是一个特殊的存储数据的类型，它提供了一套标准的接口用来获取数据、操作数据。系统也提供了音频、视频、图像和个人信息等几个常用的ContentProviders。如果你想公开自己的私有数据，可以创建自己的Content Provider类，或者当你对这些数据拥有控制、写入的权限时讲这些数据添加到ContentProvider中实现共享。外部访问通过ContentResolver去访问并操作这些被暴露的数据。
组织数据主要包括：存储数据，读取数据，以数据库的方式暴露数据。数据的存储需要根据设计的需求，选择合适的存储结构，首选数据库，当然也可以选择本地其他文件，甚至可以是网络上的数据。数据的读取，以数据库的方式暴露数据这就要求，无论数据是如何存储的，数据最后必须以数据的方式访问。



【001】如何将一个Activity设置成窗口的样式。
      在AndroidManifest.xml中定义Activity的地方一句话android:theme="@android:style/Theme.Dialog"或android:theme="@android:style/Theme.Translucent"就变成半透明的
【002】 如何退出Activity？如何安全退出已调用多个Activity的Application？
对于单一Activity的应用来说，退出很简单，直接finish()即可。
当然，也可以用killProcess()和System.exit()这样的方法。
但是，对于多Activity的应用来说，在打开多个Activity后，如果想在最后打开的Activity直接退出，上边的方法都是没有用的，因为上边的方法都是结束一个Activity而已。
当然，网上也有人说可以。
就好像有人问，在应用里如何捕获Home键，有人就会说用keyCode比较KEYCODE_HOME即可，而事实上如果不修改framework，根本不可能做到这一点一样。
所以，最好还是自己亲自试一下。
那么，有没有办法直接退出整个应用呢？
在2.1之前，可以使用ActivityManager的restartPackage方法。
它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。
注意不要被它的名字迷惑。
可是，在2.2，这个方法失效了。
在2.2添加了一个新的方法，killBackgroundProcesses()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId="android.uid.system"属性同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。因为需要在Android.mk中添加LOCAL_CERTIFICATE:= platform。而Android.mk是用于在Android源码下编译程序用的。从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。
现提供几个方法，供参考：
1、抛异常强制退出：
该方法通过抛异常，使程序Force Close。
验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。
2、记录打开的Activity：
每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。
3、发送特定广播：
在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。
4、递归退出
在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。
除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。
但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。
【003】请介绍下Android中常用的五种布局。
FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）
【004】请介绍下Android的数据存储方式。
一.SharedPreferences方式
二.文件存储方式
三.SQLite数据库方式
四.内容提供器（Contentprovider）方式
五. 网络存储方式
【005】请介绍下ContentProvider是如何实现数据共享的。
创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。
【006】如何启用Service，如何停用Service。
Android中的service类似于windows中的service，service一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。
一。步骤
第一步：继承Service类
publicclass SMSService extends Service { }
第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:
<serviceandroid:name=".DemoService" />
二。Context.startService()和Context.bindService
服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。
1.使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。
使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
2.采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，
接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并
不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。
3.采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，
接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。






1、        Android的四大组件是哪些，它们的作用？        
2、        请介绍下Android中常用的五种布局。        
3、        android中的动画有哪几类，它们的特点和区别是什么        
4、        android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。        
5、        ListView的优化方案        
6、        请介绍下Android的数据存储方式。        
7、        activity的启动模式有哪些？是什么含义？        
8、        跟activity和Task 有关的 Intent启动方式有哪些？其含义？        
9、        请描述下Activity的生命周期。        
10、        activity在屏幕旋转时的生命周期        
11、        如何启用Service，如何停用Service。        
12、        注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。                
13、        请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。                
14、        简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver        
15、        说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？        
16、        什么是ANR 如何避免它？        
17、        什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？        
18、        描述一下android的系统架构        
19、        请介绍下ContentProvider是如何实现数据共享的。        
20、        Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？        
21、        IntentService有何优点?        
22、        如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？                
23、        如何将一个Activity设置成窗口的样式。        
24、        如何退出Activity？如何安全退出已调用多个Activity的Application？        
25、        AIDL的全称是什么？如何工作？能处理哪些类型的数据？        
26、        请解释下Android程序运行时权限与文件系统权限的区别。        
27、        系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。        
28、        android系统的优势和不足        
29、        Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念        
30、        sim卡的EF文件是什么？有何作用        





1. 下列哪些语句关于内存回收的说明是正确的? (b ) 
　　A、 程序员必须创建一个线程来释放内存
　　B、 内存回收程序负责释放无用内存
　　C、 内存回收程序允许程序员直接释放内存
　　D、 内存回收程序可以在指定的时间释放内存对象



　　2. 下面异常是属于Runtime Exception 的是(abcd)(多选) 
　　A、ArithmeticException
　　B、IllegalArgumentException
　　C、NullPointerException
　　D、BufferUnderflowException



　　3. Math.round(11.5)等于多少(). Math.round(-11.5)等于多少(c). 
　　A、11 ,-11　　 B、11 ,-12　　 C、12 ,-11 　　D、12 ,-12



　　4. 下列程序段的输出结果是：(b )
void complicatedexpression_r(){
　　int x=20, y=30;
　　boolean b;
　　b=x>50&&y>60||x>50&&y<-60||x<-50&&y>60||x<-50&&y<-60;
　　System.out.println(b);
　　}
　　A、true 　　B、false 　　C、1 　　D、0



　　5. 对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行(d) 
A、onPause() B、onCreate() C、 onResume() D、onStart()



　　6. Intent传递数据时，下列的数据类型哪些可以被传递(abcd)(多选) 
A、Serializable B、charsequence C、Parcelable D、Bundle



　　7. android 中下列属于Intent的作用的是(c) 
　　A、实现应用程序间的数据共享
　　B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失
　　C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带
　　D、处理一个应用程序整体性的工作


　　8. 下列属于SAX解析xml文件的优点的是(b)
　　A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能
　　B、不用事先调入整个文档，占用资源少
　　C、整个文档调入内存，浪费时间和空间
　　D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会消失



　　9. 下面的对自定style的方式正确的是
A、 <resources>
       <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
                     </style>
</resources>
     B、 <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
   </style>
     C、 <resources>
                            <itemname="android:layout_width">fill_parent</item>
  </resources>
     D、 <resources>
                            <stylename="android:layout_width">fill_parent</style>
  </resources>



　　10. 在android中使用Menu时可能需要重写的方法有(ac)。(多选) 
　　A、onCreateOptionsMenu()
　　B、onCreateMenu()
　　C、onOptionsItemSelected()
　　D、onItemSelected()


本帖最后由 叹世残者 于 2014-4-12 16:51 编辑


【附件】
游客，如果您要查看本帖隐藏内容请回复


1.GC是什么? 为什么要有GC?
GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

2.XML包括哪些解释技术，区别是什么？
DOM和SAX
DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。
SAX至上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能任意读取节点，并且不能对节点进行增加、修改和删除。

3.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?
switch能作用在byte、char、short和int上，JDK1.7后可以作用在String上。

4."=="和equals方法究竟有什么区别？
==和equals都可以比较地址。==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals就是比较字符串内容。

5.构造方法能否被重写和重载？
构造方法不能被重写但是能被重载。

6.面向对象的特征有哪些？
封装、继承、多态和抽象。

7.抽象类和接口的区别？
1).抽象类是abstract class修饰，接口是interface修饰。
2).抽象类可以有任意类型的属性，接口只能有静态常量修饰的属性。
3).抽象类可以有普通方法和抽象法方法，接口的方法都是抽象方法。
4).抽象类和接口都不能实例化，但是抽象类有构造方法，接口没有构造方法。
5).抽象类只能单根继承，接口可以多重实现。

8.内部类可以引用它的包含类的成员吗？有没有什么限制？ 
可以引用。如果需要指定当前类时要用外部类.this来引用。如果引用局部变量，需要将局部变量指定为final。

9.String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
2个对象。"xyz"创建在字符串常量池中，new String()创建在堆中。

10.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? 
会在return前执行。