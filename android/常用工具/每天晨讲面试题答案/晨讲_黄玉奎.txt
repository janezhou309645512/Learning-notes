（一）设计模式，提供了很多软件工程问题所需处理的解决方案。

根据模式的目的可分为3类：
1.创建型模式：与对象的创建有关。
2.结构性模式：处理类与对象的组合。
3.行为性模式：对类或对象怎样交互和怎样 分配职责进行描述。

面向对象设计的2个基本原则:
1.针对接口编程，而不是针对实现编程。
2.优先使用对象组合，而不是类继承。 

面向对象设计的5个设计原则：
1.单一职责原则(SRP)
2.开放封闭原则(OCP) 
3.Liskov替换原则(LSP)
4.依赖倒置原则(DIP)
5.接口隔离原则(ISP) 

23中设计模式：

1.创建型模式：
(1).工厂方法模式
(2).抽象工厂模式
(3).创建者模式
(4).原型模式
(5).单例模式

2.结构型模式：
(6).适配器模式
(7).桥模式
(8).组合模式
(9).装饰模式
(10).外观模式
(11).享元模式
(12).代理模式

3.行为型模式
(13).解释器模式
(14).模板方法模式
(15).职责链模式
(16).命令模式
(17).迭代器模式
(18).中介者模式
(19).备忘录模式
(20).观察者模式
(21).状态模式
(22).策略模式
(23).访问者模式

备忘录模式，在工作代码中，要么不用，要么经常用到。
举个例子，程序员喜欢写代码，这个时候它的状态是很high，但是每隔一段时间总要去上一下厕所，状态是放松relax，上完测试归来后又恢复到high的状态，继续coding。这个过程对于身后的老板来说，它默认同意你离开去上厕所，他也希望你回来后恢复high的状态继续工作，但是你在这个过程中上厕所的这件事，他是不需要了解细节的，而且做为当事人你也不希望他了解你上厕所的细节吧，你只要回来后恢复激情high着继续工作，老板应该就不会挑你的刺。
这就是备忘录模式。
本文今天就Canvas的一个save(),restore()操作分析一下，但是有一点，看完本文，如果不懂备忘录模式的，应该还是不懂，但是canvas是android的一场大戏，说一说它的特色，对深入学习android绝对有帮助。
学习备忘录模式，通过保存状态，恢复状态的内部实现，对了解一些莫名其妙的看上去无用其实很重要的操作有拨开云雾见青天的作用。

1. 意图

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态。


2. 结构
 
组织者，把原发器的状态State（全部或者部分状态，一般是变量的值），通过CreateMemento()方法保存起来，继续运行后，等待合适的时机，在通过SetMemento()方法可以再次恢复到之前的状态。在这个过程中，我们并没有对这些状态做任何的访问和设置，实际上这些状态都是私有的，对外是禁止访问的，我们只是通过Memento对象的两个最简单的方法就达到了这个效果。Memento经常写成Originator的内部类。
在Android中，Canvas有两个方法 save()和restore()方法再做图形变换的时候使用的非常多，因为涉及到跨语言的问题，我不好就认定这个用的是备忘录模式，但是它的这种思想绝对是备忘录的思想。

3. 效果
(1).保持封装边界，把很复杂的原发器的内部信息对外部其他对象隐藏起来。
(2).简化的原发器，把状态操作无形中转化到客户手里，简化了原发器的某些实现。
(3).也要注意注意备忘录的管理代价。



（二）ScrollView简单介绍

滚动视图（ScrollView）是指当拥有很多内容，屏幕显示不完时，需要通过滚动来显示完整的视图。包括水平滚动视图（HorizontalScrollView）和垂直滚动视图（ScrollView）
它是一种可供用户滚动的层次结构布局容器，允许显示比实际多的内容。ScrollView是一种FrameLayout，意味需要在其上放置有自己滚动内容的子元素。子元素可以是一个复杂的对象的布局管理器。通常用的子元素是垂直方向的LinearLayout，显示在最上层的垂直方向可以让用户滚动的箭头。ScrollView只支持垂直方向的滚动。

隐藏滚动条
1、标签属性：android:scrollbars="none"
2、代码设置：
setHorizontalScrollBarEnabled(false);//隐藏横向ScorollView
setVerticalScrollBarEnabled(false);//隐藏纵向ScorollView

setOnTouchListener的使用：判断ScrollView何时滑动到底部
1、getScorollY()――滚动条滑动的距离
2、getMeasuredHeight()――内容的整体高度，包括隐藏部分
3、getHeight()――显示高度。内容未布满屏幕，2=3；内容大于屏幕，3=屏幕高度，2>3。
4、getChildAt(int i)――获取ScorollView的第i个子控件

scrollTo和scrollBy：控制ScrollView视图的位置


（三）Uri类简介
Uri代表了要操作的数据，Uri主要包含了两部分信息：1.需要操作的ContentProvider ，2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：
1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…
2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。
3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：
要操作contact表中id为10的记录，可以构建这样的路径:/contact/10
要操作contact表中id为10的记录的name字段， contact/10/name
要操作contact表中的所有记录，可以构建这样的路径:/contact?
要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:
要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name
如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：
Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)

（四）Fragment与Activity之间的通信

1.直接在一个Fragment中调用另外一个Fragment中的方法
ContentFragment cf = (ContentFragment) getActivity().getFragmentManager().findFragmentById(R.id.content_fg);
                            cf.showPro(name);
public void showPro(String key) {
    list = map.get(key);
    adapter = new ArrayAdapter<string>(getActivity(),
            android.R.layout.simple_list_item_1, list);
    lv.setAdapter(adapter);
}</string>

2.使用接口
接口可以实现两个Fragment之间的通信，也可以实现Fragment和Activity之间的通信，这是用的比较多的一种方式，使用接口来实现两个Fragment之间通信，要通过宿主Activity中转一下，如果是Fragment和宿主Activity通信则直接调用即可

3.使用广播
不论我们有没有用ViewPager，都可以用广播实现两个Fragment之间的通信，广播算是这里最灵活的通信方式了